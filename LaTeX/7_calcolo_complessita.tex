\chapter{Calcolo delle complessità computazionali degli pseudocodici proposti}
Analizziamo ora dal punto di vista della complessità computazionale gli algoritmi che sono stati proposti (\cref{codice}) per affrontare la risoluzione del gioco del 15. L’obiettivo è valutare, per ciascun approccio, l’ordine di grandezza del tempo di esecuzione e dello spazio in memoria richiesto.

\section{Calcolo dell'esistenza del routing number}
Come già descritto nel \cref{routing number}, l'algoritmo descritto ha una complessità temporale che dipende dalla struttura del grafo e dal numero di nodi $n$. In particolare:

\begin{itemize}
    \item Il calcolo che coinvolge una BFS per ogni nodo, ha una complessità di $O(n + m)$, dove $n$ è il numero di nodi e $m$ il numero di archi nel grafo.
    \item In generale, il numero massimo di passi necessari è di $O(n+m)$;
\end{itemize}

Pertanto, la complessità complessiva dell'algoritmo è $O(n+m)$.

\section{Algoritmo di verifica di risolvibilità}
Anche questo algoritmo è già stato analizzato all'interno del \cref{modellazione}. Ribadiamo che a causa del doppio ciclo for utilizzato per contare le inversioni l'algoritmo ha una complessità pari a $O(n^2)$. 

\section{Algoritmo risolutivo: A*}
La complessità temporale di A* è espressa in funzione di due parametri fondamentali:\begin{itemize}
    \item \textbf{$b$}: fattore di branching (numero medio di successori per nodo);
    \item \textbf{$d$}: profondità della soluzione ottima;
\end{itemize}
Nel caso peggiore, A* presenta una complessità temporale di $\mathcal{O}(b^d)$, equivalente a quella di una ricerca in ampiezza. Tuttavia, questa rappresenta uno scenario che raramente si verifica.

In generale A* ha una complessità: 
\begin{itemize} 
    \item \textbf{Caso migliore}: quando l'euristica è perfetta A* esplora solo i nodi lungo il percorso ottimo, risultando in una complessità temporale $\mathcal{O}(d)$.
    \item \textbf{Caso peggiore}: A* degenera in una ricerca con complessità $\mathcal{O}(b^d)$ equivalente a una in ampiezza;
    \item \textbf{Caso medio}: con euristiche ammissibili la complessità si riduce rispetto al caso peggiore nell'ordine di $\mathcal{O}(b^{d \cdot \varepsilon})$ dove $\varepsilon < 1$ dipende dalla qualità dell'euristica.
\end{itemize}

La complessità di A* dipende quindi fortemente dall'euristica che viene utilizzata. 

\subsection{Analisi della Complessità nell'Implementazione}
Nel codice implementato per il gioco del 15 il fattore di branching è limitato a 4 (movimenti nelle quattro direzioni).

Nell'implementazione però vengono usati vari metodi per "filtrare" la ricerca.
Il seguente frammento di codice illustra la generazione e il filtraggio dei nodi successori:

\begin{lstlisting}[language=Java, caption=Generazione dei nodi successori]
for (Board neighbor : neighborsList) {
    if (!visited.contains(neighbor)) {
        visited.add(neighbor);
        openSet.add(new State(neighbor, current.moves + 1, current));
    }
}
\end{lstlisting}

Il fattore di branching viene in questo modo ridotto in quanto:
\begin{enumerate}
    \item la tessera vuota può avere 2, 3 o 4 movimenti possibili a seconda della posizione;
    \item l'utilizzo del \texttt{Set<Board> visited} elimina la rivisitazione degli stati;
\end{enumerate}

La funzione di priorità implementata segue la formulazione classica di A*:
$$f(n) = g(n) + h(n)$$

dove $g(n)$ rappresenta il costo del percorso dalla radice al nodo $n$, e $h(n)$ è la stima euristica del costo dal nodo $n$ alla soluzione.

\begin{lstlisting}[language=Java, caption=Implementazione della funzione di priorità]
public int priority() {
    return this.moves + config.manhattan();
}
\end{lstlisting}

L'euristica combinata utilizza:
\begin{itemize}
    \item \textbf{Distanza di Manhattan}: $\mathcal{O}(1)$ calcola la distanza di ogni pedina dalla posizione "obiettivo"; 
    \item \textbf{Numero di mosse}: $\mathcal{O}(n)$ il numero esatto di mosse dalla configurazione iniziale
\end{itemize}

\begin{lstlisting}[language=Java, caption=Calcolo delle distanze di Manhattan]
        public int manhattan() {
        int dist = 0;
        for (int i = 0; i < this.firstDimension; i++) {
            for (int j = 0; j < this.secondDimension; j++) {
                int value = board[i][j];
                if (value != empty) {
                    Pair targetPosition = pos.get(value); 
                    dist += Math.abs(i - targetPosition.first) + Math.abs(j - targetPosition.second);

                }
            }
        }
        return dist;
    }
\end{lstlisting}

La distanza di Manhattan ha complessità computazionale $O(N^2)$ per puzzle $N×N$ in quanto, in questo caso, il calcolo viene svolto ogni volta, cioè non viene utilizzata alcuna tecnica di memoizzazione. 
Nel caso di utilizzo di memoizzazione tale complessità è riducibile al valore di $O(1)$.


Il codice include una verifica preliminare che previene calcoli inutili nel caso di disposizioni che non sono risolvibili. 
La complessità di questo codice è già stata trattata ed è nell'ordine di $O(n^2)$.


Questa ottimizzazione elimina a priori le configurazioni non risolvibili, evitando esplorazioni infinite dello spazio degli stati.


L'implementazione utilizza strutture dati ottimizzate per le operazioni critiche:
\begin{lstlisting}[language=Java, caption=Inizializzazione delle strutture dati]
PriorityQueue<State> openSet = new PriorityQueue<>();
Set<Board> visited = new HashSet<>();
\end{lstlisting}
Le complessità delle operazioni fondamentali sono:
\begin{itemize}
    \item \textbf{PriorityQueue.poll()}: $O(logn)$ per l'estrazione del nodo con priorità minima;
    \item \textbf{HashSet.contains()}: $O(1)$ medio per la verifica di appartenenza;
    \item \textbf{PriorityQueue.add()}: $O(logn)$ per l'inserimento ordinato;
\end{itemize}

Il confronto tra stati è implementato direttamente nella classe \texttt{State}:
\begin{lstlisting}[language=Java, caption=Implementazione del comparatore, float=h]
@Override
public int compareTo(State y) {
if (this.priority() > y.priority()) {
return 1;
} else if (this.priority() < y.priority()) {
return -1;
} else {
return 0;
}
}
\end{lstlisting}
Questa implementazione garantisce un ordinamento corretto degli stati nella coda di priorità, fondamentale per il funzionamento ottimale di A*.

La distanza di Manhattan, pur essendo ammissibile, presenta una limitazione:
\begin{itemize}
    \item \textbf{Non considera i conflitti}: tessere che si bloccano reciprocamente non sono rilevate
\end{itemize}

Questa può portare a un aumento del numero di nodi esplorati rispetto a euristiche più informative come quella che combina Manhattan e conflitti lineari.

L'algoritmo A* implementato con la distanza di Manhattan come euristica presenta una complessità temporale teorica $O(b^d)$ con prestazioni che dipendono fortemente dalla qualità dell'euristica.

\subsection{Algoritmo: A* con conflitti lineari}

La versione dell'algoritmo A* implementata considera, oltre alla distanza di Manhattan, anche i \emph{conflitti lineari} come parte dell'euristica. Questa scelta consente di rendere l'euristica più informativa e ridurre il numero di nodi esplorati.

\begin{itemize}
    \item La funzione di priorità $f(n)$ viene calcolata come:
    \[
        f(n) = g(n) + h(n) = \text{\#mosse dalla radice} + (\text{distanza di Manhattan} + \text{conflitti lineari})
    \]I conflitti lineari permettono di rilevare situazioni in cui due o più tessere si bloccano reciprocamente sulla stessa riga o colonna, aumentando il valore dell'euristica in modo da scoraggiare percorsi non ottimali.

    \item La classe \texttt{State} è stata aggiornata affinché il metodo \texttt{priority()} includa il calcolo dei conflitti lineari:
\begin{lstlisting}[language=Java]
public int priority() {
    return config.linearConflicts() + config.manhattan();
}
\end{lstlisting}
    \item La struttura dei nodi successori e la gestione della coda di priorità rimangono identiche, ma la combinazione di Manhattan e conflitti lineari migliora la selezione del nodo successivo da esplorare.
\end{itemize}

\begin{itemize}
    \item L'aggiunta dei conflitti lineari aumenta il costo computazionale per il calcolo dell'euristica di ciascun nodo. Il numero totale di nodi esplorati diminuisce sensibilmente rispetto all'uso della sola distanza di Manhattan.
    \item La complessità temporale rimane $\mathcal{O}(b^d)$ nel caso peggiore, ma nella pratica il fattore di branching effettivo viene ridotto grazie alla guida più precisa.
    \item L'implementazione continua a utilizzare un \texttt{HashSet} per i nodi visitati, evitando di riesplorare stati già considerati durante la ricerca.
\end{itemize}
Questa versione dell'algoritmo permette di ottenere soluzioni più rapide e vicine al numero minimo di mosse rispetto all'A* basato solo sulla distanza di Manhattan, grazie alla maggiore precisione dell'euristica combinata.

\section{Algoritmo risolutivo: IDA*}

L'algoritmo IDA* (Iterative Deepening A*) è una variante dell'A* che combina la profondità limitata tipica della DFS con l'euristica di A*. A differenza di A*, IDA* utilizza una soglia (threshold) per guidare la ricerca in profondità, evitando di memorizzare tutti i nodi esplorati e riducendo significativamente l'uso della memoria.
\begin{itemize}
    \item La funzione di costo $f(n) = g(n) + h(n)$ è calcolata esattamente come in A*, dove $g(n)$ è il numero di mosse dalla radice e $h(n)$ è l'euristica (somma di Manhattan e conflitti lineari, se implementata).
    \item La soglia iniziale viene impostata al costo del nodo iniziale $f(start)$.
    \item L'algoritmo esegue una ricerca in profondità limitata dalla soglia. Se un nodo supera la soglia, viene ignorato, ma viene registrato il minimo $f$ oltre la soglia per aggiornare la soglia nella prossima iterazione.
    \item La lista \texttt{visited} serve solo per evitare cicli all'interno della stessa iterazione ricorsiva, consentendo però di riesplorare gli stessi nodi in iterazioni successive.
\end{itemize}
L'implementazione utilizza:
\begin{itemize}
    \item Una classe \texttt{State} che rappresenta ciascun stato del puzzle, memorizzando la configurazione, il numero di mosse e il nodo precedente per ricostruire il percorso.
    \item Un metodo ricorsivo \texttt{search} che esplora i vicini di ciascuno stato secondo la logica DFS e confronta $f(n)$ con la soglia corrente.
    \item La soglia viene aggiornata a ogni iterazione con il minimo $f(n)$ dei nodi che l'hanno superata, permettendo di approfondire gradualmente lo spazio degli stati.
\end{itemize}

Nel calcolo della complessità IDA* si distingue principalmente per l'uso della memoria che fa: 

\begin{itemize}
    \item \textbf{Memoria:} $O(d)$, dove $d$ è la profondità massima della soluzione. L'algoritmo memorizza solo il percorso corrente nella ricorsione, evitando di salvare tutti i nodi visitati come fa A*.
    \item \textbf{Tempo:} nel caso peggiore, IDA* può visitare ripetutamente gli stessi nodi in iterazioni successive. La complessità temporale è quindi $O(b^d)$, simile a quella di A*, ma con un fattore moltiplicativo dovuto alle ripetizioni dovute all’approccio iterativo.
    \item L'uso della lista \texttt{visited} locale riduce i cicli durante la DFS, ma non elimina completamente le riesplorazioni tra iterazioni successive.
\end{itemize}

IDA* richiede quindi molta meno memoria, in quanto non mantiene tutti i nodi esplorati in una coda di priorità globale.

\section{Tabella riassuntiva}
\begin{table}[h!]
\centering
\caption{Confronto tra A*, A* con conflitti lineari e IDA* per il gioco del 15}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|p{4cm}|p{4cm}|p{4cm}|}
\hline
\textbf{Caratteristica} & \textbf{A*} & \textbf{A* con conflitti lineari} & \textbf{IDA*} \\
\hline
Strategia di ricerca & Best-First (coda di priorità) & Best-First (coda di priorità) & Depth-First iterativa \\
\hline
Funzione costo & $f(n) = g(n) + h(n)$ & $f(n) = g(n) + h(n)$ (Manhattan + conflitti lineari) & $f(n) = g(n) + h(n)$ \\
\hline
Memoria richiesta & $O(b^d)$ & $O(b^d)$ & $O(d)$ \\
\hline
Tempo nel caso peggiore & $O(b^d)$ & $O(b^d)$ & $O(b^d)$ (riesplorazioni incluse) \\
\hline
Tempo nel caso migliore & $O(d)$ se l’euristica è perfetta & $O(d)$ se l’euristica è perfetta & $O(d)$ se l’euristica è perfetta \\
\hline
Tempo medio & Dipende dalla qualità dell’euristica & Migliore di A* grazie ai conflitti lineari & Dipende dal numero di soglie aggiornate \\
\hline
Uso dell’euristica & Manhattan & Manhattan + conflitti lineari & Manhattan (o altra euristica) \\
\hline
Gestione dei nodi già visitati & Evita rivisitazioni usando \texttt{visited} globale & Evita rivisitazioni usando \texttt{visited} globale & Evita cicli solo nella DFS corrente \\
\hline
\end{tabular}%
}
\end{table}





